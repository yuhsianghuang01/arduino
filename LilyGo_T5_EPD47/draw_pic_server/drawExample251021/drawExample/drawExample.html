<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>EPD Controller</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: Arial;
      padding: 10px;
      background: #f5f5f5;
    }

    button {
      margin: 5px;
      padding: 10px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      opacity: 0.8;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .upload,
    .text-control {
      margin-top: 20px;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .form-row {
      margin: 10px 0;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
    }

    label {
      display: inline-block;
      width: 80px;
      font-weight: bold;
      margin-right: 10px;
    }

    input[type="text"],
    input[type="number"] {
      padding: 8px;
      margin: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    input[type="range"] {
      width: 200px;
      margin: 0 10px;
    }

    input[type="file"] {
      padding: 8px;
      border: 2px dashed #ccc;
      border-radius: 4px;
      width: 100%;
    }

    input[type="file"]:hover {
      border-color: #4CAF50;
    }

    .color-value {
      font-weight: bold;
      color: #2196F3;
      margin-left: 10px;
    }

    /* æ™ºèƒ½åœ–ç‰‡æ§åˆ¶å°ˆç”¨æ¨£å¼ */
    .upload h3 {
      color: #333;
      border-bottom: 2px solid #4CAF50;
      padding-bottom: 8px;
    }

    .upload h4 {
      color: #666;
      margin: 20px 0 10px 0;
    }

    #imagePreviewCanvas {
      max-width: 100%;
      height: auto;
      border: 2px solid #333;
      border-radius: 4px;
      background: white;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    #positionInfo {
      font-family: monospace;
      background: #f0f0f0;
      padding: 8px;
      border-radius: 4px;
      margin-top: 10px;
      border-left: 4px solid #2196F3;
    }

    #uploadProgress {
      background: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }

    #progressBar {
      background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
      height: 24px;
      border-radius: 12px;
      transition: width 0.5s ease;
      position: relative;
      overflow: hidden;
    }

    #progressBar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 33%, rgba(255, 255, 255, .3) 33%, rgba(255, 255, 255, .3) 66%, transparent 66%);
      animation: progressShine 2s infinite;
    }

    @keyframes progressShine {
      0% {
        transform: translateX(-100%);
      }

      100% {
        transform: translateX(100%);
      }
    }

    small {
      color: #666;
      font-style: italic;
      margin-left: 10px;
    }

    /* æŒ‰éˆ•æ¨£å¼å¢å¼· */
    button[onclick*="fit"] {
      background: #2196F3;
      color: white;
    }

    button[onclick*="keep"] {
      background: #FF9800;
      color: white;
    }

    button[onclick*="center"] {
      background: #9C27B0;
      color: white;
    }

    button[onclick*="invert"] {
      background: #607D8B;
      color: white;
    }

    button[onclick*="reset"] {
      background: #795548;
      color: white;
    }

    #sendImageBtn {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
      font-weight: bold;
      border: none;
      padding: 15px 30px;
      font-size: 18px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
      transition: all 0.3s ease;
    }

    #sendImageBtn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(76, 175, 80, 0.4);
    }

    /* Canvas æ‰‹å¯«æ¿æ¨£å¼ */
    .canvas-container {
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 5px;
      text-align: center;
    }

    #drawingCanvas {
      border: 2px solid #333;
      cursor: crosshair;
      width: 100%;
      max-width: 800px;
      background-color: white;
    }

    .canvas-controls {
      margin: 10px 0;
    }

    .canvas-controls button {
      margin: 2px 5px;
      padding: 8px 15px;
    }
  </style>
</head>

<body>
  <h2>EPD Web Controller</h2>
  <button onclick="fetch(&quot;/clear&quot;)">Clear Screen</button>
  <button onclick="fetch(&quot;/draw/line&quot;)">Draw Random Line</button>
  <button onclick="fetch(&quot;/draw/rect&quot;)">Draw Random Rect</button>
  <button onclick="fetch(&quot;/draw/circle&quot;)">Draw Random Circle</button>

  <div class="canvas-container">
    <h3>æ‰‹å¯«ç¹ªåœ–æ¿ (å°å°ºå¯¸æ¸¬è©¦ç‰ˆ)</h3>
    <p>æ³¨æ„ï¼šä½¿ç”¨100x60å°å°ºå¯¸ç¢ºä¿æ•¸æ“šå‚³è¼¸ç©©å®šï¼Œå°‡è‡ªå‹•ç¸®æ”¾åˆ°EPD</p>
    <canvas id="drawingCanvas" width="100" height="60"></canvas>
    <div class="canvas-controls">
      <button onclick="clearCanvas()">æ¸…é™¤ç•«å¸ƒ</button>
      <button onclick="sendCanvasToEPD()">åŒæ­¥åˆ°EPD</button>
      <label>ç­†åˆ·å¤§å°:</label>
      <input type="range" id="brushSize" min="1" max="20" value="3" oninput="updateBrushSize()">
      <span class="color-value" id="brushSizeValue">3</span>
      <label>ç­†åˆ·é¡è‰²:</label>
      <input type="range" id="brushColor" min="0" max="15" value="0" oninput="updateBrushColor()">
      <span class="color-value" id="brushColorValue">0 (é»‘è‰²)</span>
    </div>
  </div>

  <div class="text-control">
    <h3>æ–‡å­—æ§åˆ¶</h3>
    <div class="form-row">
      <label>æ–‡å­—:</label>
      <input type="text" id="text" placeholder="è¼¸å…¥æ–‡å­—" value="Hello EPD">
    </div>
    <div class="form-row">
      <label>Xåº§æ¨™:</label>
      <input type="number" id="x" min="0" max="540" value="50">
      <label>Yåº§æ¨™:</label>
      <input type="number" id="y" min="0" max="960" value="50">
    </div>
    <div class="form-row">
      <label>å­—é«”å¤§å°:</label>
      <input type="range" id="fontSize" min="1" max="100" value="2" oninput="updateFontSizeValue()">
      <span class="color-value" id="fontSizeValue">2</span>
    </div>
    <div class="form-row">
      <label>æ–‡å­—é¡è‰²:</label>
      <input type="range" id="textColor" min="0" max="15" value="0" oninput="updateTextColorValue()">
      <span class="color-value" id="textColorValue">0 (é»‘è‰²)</span>
    </div>
    <div class="form-row">
      <label>èƒŒæ™¯é¡è‰²:</label>
      <input type="range" id="bgColor" min="0" max="16" value="16" oninput="updateBgColorValue()">
      <span class="color-value" id="bgColorValue">é€æ˜</span>
    </div>

    <div class="form-row">
      <label>é è¨­æ¨£å¼:</label>
      <button onclick="setStyle(&quot;title&quot;)" style="margin:2px; padding:5px;">æ¨™é¡Œ</button>
      <button onclick="setStyle(&quot;normal&quot;)" style="margin:2px; padding:5px;">æ­£æ–‡</button>
      <button onclick="setStyle(&quot;highlight&quot;)" style="margin:2px; padding:5px;">å¼·èª¿</button>
      <button onclick="setStyle(&quot;subtitle&quot;)" style="margin:2px; padding:5px;">å‰¯æ¨™é¡Œ</button>
    </div>

    <button onclick="drawText()">ç¹ªè£½æ–‡å­—</button>

    <h4>å¤šè¡Œæ–‡å­—</h4>
    <div class="form-row">
      <label>å¤šè¡Œæ–‡å­—:</label>
      <textarea id="multiText" placeholder="è¼¸å…¥å¤šè¡Œæ–‡å­—ï¼Œç”¨åˆ†è™Ÿ(;)åˆ†éš”" rows="3" style="width:300px;">ç¬¬ä¸€è¡Œæ–‡å­—;ç¬¬äºŒè¡Œæ–‡å­—;ç¬¬ä¸‰è¡Œæ–‡å­—</textarea>
    </div>
    <div class="form-row">
      <label>èµ·å§‹X:</label>
      <input type="number" id="startX" min="0" max="540" value="50">
      <label>èµ·å§‹Y:</label>
      <input type="number" id="startY" min="0" max="960" value="100">
    </div>
    <div class="form-row">
      <label>è¡Œé«˜:</label>
      <input type="number" id="lineHeight" min="10" max="100" value="25">
    </div>
    <button onclick="drawMultiText()">ç¹ªè£½å¤šè¡Œæ–‡å­—</button>
  </div>

  <div class="text-control">
    <h3>é€²éšç¹ªåœ–æ§åˆ¶</h3>

    <h4>ç•«ç·šæ§åˆ¶</h4>
    <div class="form-row">
      <label>èµ·é»X:</label>
      <input type="number" id="lineX1" min="0" max="540" value="50">
      <label>èµ·é»Y:</label>
      <input type="number" id="lineY1" min="0" max="960" value="50">
    </div>
    <div class="form-row">
      <label>çµ‚é»X:</label>
      <input type="number" id="lineX2" min="0" max="540" value="200">
      <label>çµ‚é»Y:</label>
      <input type="number" id="lineY2" min="0" max="960" value="100">
    </div>
    <div class="form-row">
      <label>ç·šæ¢é¡è‰²:</label>
      <input type="range" id="lineColor" min="0" max="15" value="0" oninput="updateLineColorValue()">
      <span class="color-value" id="lineColorValue">0 (é»‘è‰²)</span>
    </div>
    <div class="form-row">
      <label>ç·šæ¢ç²—ç´°:</label>
      <input type="range" id="lineThickness" min="1" max="20" value="1" oninput="updateLineThicknessValue()">
      <span class="color-value" id="lineThicknessValue">1</span>
    </div>
    <button onclick="drawLineAdvanced()">ç¹ªè£½ç·šæ¢</button>

    <h4>ç•«åœ“æ§åˆ¶</h4>
    <div class="form-row">
      <label>åœ“å¿ƒX:</label>
      <input type="number" id="circleX" min="0" max="540" value="200">
      <label>åœ“å¿ƒY:</label>
      <input type="number" id="circleY" min="0" max="960" value="200">
    </div>
    <div class="form-row">
      <label>åŠå¾‘:</label>
      <input type="number" id="circleRadius" min="1" max="500" value="50">
    </div>
    <div class="form-row">
      <label>å¤–æ¡†:</label>
      <input type="checkbox" id="circleBorder" checked>
      <label>å¤–æ¡†é¡è‰²:</label>
      <input type="range" id="circleBorderColor" min="0" max="15" value="0" oninput="updateCircleBorderColorValue()">
      <span class="color-value" id="circleBorderColorValue">0 (é»‘è‰²)</span>
    </div>
    <div class="form-row">
      <label>å¤–æ¡†ç²—ç´°:</label>
      <input type="range" id="circleBorderThickness" min="1" max="10" value="1"
        oninput="updateCircleBorderThicknessValue()">
      <span class="color-value" id="circleBorderThicknessValue">1</span>
    </div>
    <div class="form-row">
      <label>å¡«æ»¿:</label>
      <input type="checkbox" id="circleFill">
      <label>å¡«å……é¡è‰²:</label>
      <input type="range" id="circleFillColor" min="0" max="15" value="15" oninput="updateCircleFillColorValue()">
      <span class="color-value" id="circleFillColorValue">15 (ç™½è‰²)</span>
    </div>
    <button onclick="drawCircleAdvanced()">ç¹ªè£½åœ“å½¢</button>

    <h4>ç•«çŸ©å½¢æ§åˆ¶</h4>
    <div class="form-row">
      <label>å·¦ä¸ŠX:</label>
      <input type="number" id="rectX" min="0" max="540" value="100">
      <label>å·¦ä¸ŠY:</label>
      <input type="number" id="rectY" min="0" max="960" value="150">
    </div>
    <div class="form-row">
      <label>å¯¬åº¦:</label>
      <input type="number" id="rectWidth" min="1" max="540" value="100">
      <label>é«˜åº¦:</label>
      <input type="number" id="rectHeight" min="1" max="960" value="80">
    </div>
    <div class="form-row">
      <label>å¤–æ¡†:</label>
      <input type="checkbox" id="rectBorder" checked>
      <label>å¤–æ¡†é¡è‰²:</label>
      <input type="range" id="rectBorderColor" min="0" max="15" value="0" oninput="updateRectBorderColorValue()">
      <span class="color-value" id="rectBorderColorValue">0 (é»‘è‰²)</span>
    </div>
    <div class="form-row">
      <label>å¤–æ¡†ç²—ç´°:</label>
      <input type="range" id="rectBorderThickness" min="1" max="10" value="1"
        oninput="updateRectBorderThicknessValue()">
      <span class="color-value" id="rectBorderThicknessValue">1</span>
    </div>
    <div class="form-row">
      <label>å¡«æ»¿:</label>
      <input type="checkbox" id="rectFill">
      <label>å¡«å……é¡è‰²:</label>
      <input type="range" id="rectFillColor" min="0" max="15" value="15" oninput="updateRectFillColorValue()">
      <span class="color-value" id="rectFillColorValue">15 (ç™½è‰²)</span>
    </div>
    <button onclick="drawRectAdvanced()">ç¹ªè£½çŸ©å½¢</button>
  </div>

  <div class="upload">
    <h3>Upload 1-bit or 2-bit RAW Image</h3>
    <p>Size: 540x960 (bytes: %BYTES%)</p>
    <form method="POST" action="/upload" enctype="multipart/form-data">
      <input type="file" name="image" accept=".bin,.raw">
      <input type="submit" value="Upload">
    </form>
  </div>

  <!-- EPD åœ–ç‰‡è½‰æ›å™¨æ•´åˆ -->
  <div class="text-control">
    <h3>ğŸ–¼ï¸ EPD åœ–ç‰‡è½‰æ›å™¨</h3>
    <p>å°‡ä»»ä½•åœ–ç‰‡è½‰æ›ç‚º EPD å¯ç”¨çš„ç°éšæ•¸æ“šï¼Œæ”¯æ´å‹•æ…‹å°ºå¯¸èª¿æ•´</p>

    <style>
      .converter-container {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        border: 1px solid #e9ecef;
      }

      .size-settings {
        background: #e3f2fd;
        padding: 15px;
        border-radius: 6px;
        margin-bottom: 20px;
        border-left: 4px solid #2196F3;
      }

      .size-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
        flex-wrap: wrap;
        margin: 10px 0;
      }

      .size-input-group {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .size-select {
        padding: 6px 10px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        background: white;
        min-width: 70px;
      }

      .multiply-symbol {
        font-size: 18px;
        font-weight: bold;
        color: #6c757d;
      }

      .preset-buttons {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 10px;
      }

      .preset-btn {
        background: #6c757d;
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        transition: background 0.3s;
      }

      .preset-btn:hover {
        background: #5a6268;
      }

      .preset-btn.active {
        background: #4CAF50;
      }

      .canvas-container {
        text-align: center;
        margin: 20px 0;
        border: 2px dashed #ddd;
        padding: 15px;
        border-radius: 6px;
        background: white;
      }

      #imageCanvas {
        max-width: 100%;
        border: 1px solid #ccc;
        background: #f9f9f9;
      }

      .upload-section {
        text-align: center;
        margin: 15px 0;
      }

      .file-input-wrapper {
        display: inline-block;
        background: #4CAF50;
        color: white;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.3s;
      }

      .file-input-wrapper:hover {
        background: #45a049;
      }

      .converter-textarea {
        width: 100%;
        height: 150px;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        font-family: 'Courier New', monospace;
        font-size: 11px;
        resize: vertical;
        background: #fafafa;
      }

      .converter-info {
        margin: 10px 0;
        padding: 10px;
        background: #fff3cd;
        border-radius: 4px;
        border-left: 4px solid #ffc107;
        font-size: 12px;
      }
    </style>

    <div class="converter-container">
      <div class="size-settings">
        <h4>ğŸ“ åœ–ç‰‡å°ºå¯¸è¨­å®š</h4>
        <div class="size-controls">
          <div class="size-input-group">
            <label>å¯¬åº¦:</label>
            <select id="widthSelect" class="size-select">
              <option value="32">32</option>
              <option value="64">64</option>
              <option value="128">128</option>
              <option value="200">200</option>
              <option value="320">320</option>
              <option value="480" selected>480</option>
              <option value="540">540</option>
              <option value="600">600</option>
              <option value="800">800</option>
              <option value="960">960</option>
            </select>
          </div>

          <span class="multiply-symbol">Ã—</span>

          <div class="size-input-group">
            <label>é«˜åº¦:</label>
            <select id="heightSelect" class="size-select">
              <option value="32">32</option>
              <option value="64">64</option>
              <option value="128">128</option>
              <option value="200">200</option>
              <option value="320">320</option>
              <option value="480">480</option>
              <option value="540">540</option>
              <option value="600">600</option>
              <option value="800" selected>800</option>
              <option value="960">960</option>
            </select>
          </div>
        </div>

        <div class="preset-buttons">
          <button class="preset-btn" onclick="setPresetSize(64, 64)">64Ã—64</button>
          <button class="preset-btn" onclick="setPresetSize(128, 128)">128Ã—128</button>
          <button class="preset-btn" onclick="setPresetSize(320, 240)">320Ã—240</button>
          <button class="preset-btn active" onclick="setPresetSize(480, 800)">480Ã—800</button>
          <button class="preset-btn" onclick="setPresetSize(540, 960)">540Ã—960</button>
          <button class="preset-btn" onclick="setPresetSize(800, 600)">800Ã—600</button>
        </div>
      </div>

      <div class="upload-section">
        <div class="file-input-wrapper" onclick="document.getElementById(&quot;imageInput&quot;).click()">
          <input type="file" id="imageInput" accept="image/*" style="display: none;">
          ğŸ–¼ï¸ é¸æ“‡åœ–ç‰‡æª”æ¡ˆ
        </div>
      </div>

      <div class="converter-info">
        <strong>ä½¿ç”¨èªªæ˜ï¼š</strong>
        <ul style="margin: 5px 0; padding-left: 20px;">
          <li>é¸æ“‡åœ–ç‰‡å¾Œæœƒè‡ªå‹•è½‰æ›ç‚ºæŒ‡å®šå°ºå¯¸çš„ç°éšåœ–ç‰‡</li>
          <li>ç°éšå€¼ç¯„åœï¼š0-15 (0=é»‘è‰², 15=ç™½è‰²)</li>
          <li>åœ¨ä¸‹æ–¹æ•¸æ“šæ¡†é›™æ“Šå¯è¤‡è£½æ‰€æœ‰æ•¸æ“š</li>
          <li>å¯ç›´æ¥å°‡æ•¸æ“šè²¼åˆ° "ç°éšåœ–ç‰‡æ•¸æ“šå‚³é€" åŠŸèƒ½ä½¿ç”¨</li>
        </ul>
      </div>

      <div class="canvas-container">
        <canvas id="imageCanvas" width="480" height="800"></canvas>
        <div id="canvasInfo" style="margin-top: 10px; color: #666; font-size: 12px;">
          è«‹å…ˆé¸æ“‡åœ–ç‰‡æª”æ¡ˆ
        </div>
      </div>

      <div style="margin-top: 15px;">
        <label style="display: block; margin-bottom: 8px; font-weight: bold;" id="dataLabel">
          ç°éšæ•¸æ“š (480Ã—800 = 384,000 å€‹å€¼)ï¼š
        </label>
        <textarea id="converterDataTextarea" class="converter-textarea" placeholder="è½‰æ›å¾Œçš„ç°éšæ•¸æ“šå°‡é¡¯ç¤ºåœ¨é€™è£¡..."
          readonly></textarea>
        <div style="margin-top: 5px; font-size: 11px; color: #666; font-style: italic;">
          ğŸ’¡ é›™æ“Šæ–‡å­—æ¡†å¯è¤‡è£½æ‰€æœ‰æ•¸æ“šåˆ°å‰ªè²¼ç°¿
        </div>
      </div>

      <div style="margin-top: 15px; text-align: center;">
        <button onclick="resetConverter()"
          style="background: #6c757d; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">é‡ç½®</button>
        <button onclick="downloadConverterData()"
          style="background: #17a2b8; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">ä¸‹è¼‰æ•¸æ“š</button>
      </div>
    </div>
  </div>
  <div class="text-control">
    <h3>ç°éšåœ–ç‰‡æ•¸æ“šå‚³é€</h3>
    <p>å¾å¤–éƒ¨å·¥å…·ç”Ÿæˆçš„ç°éšæ•¸æ“š (0-15ï¼Œé€—è™Ÿåˆ†éš”)</p>
    <div class="form-row">
      <label>Xåº§æ¨™:</label>
      <input type="number" id="grayscaleX" min="0" max="540" value="0">
      <label>Yåº§æ¨™:</label>
      <input type="number" id="grayscaleY" min="0" max="960" value="0">
    </div>
    <div class="form-row">
      <label>åœ–ç‰‡å¯¬åº¦:</label>
      <input type="number" id="grayscaleWidth" min="1" max="540" value="100">
      <label>åœ–ç‰‡é«˜åº¦:</label>
      <input type="number" id="grayscaleHeight" min="1" max="960" value="100">
    </div>
    <div class="form-row">
      <label>ç°éšæ•¸æ“š:</label>
      <textarea id="grayscaleData" placeholder="è²¼å…¥ç°éšæ•¸æ“šï¼Œæ ¼å¼: 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,..." rows="6"
        style="width:100%; max-width:600px; font-family:monospace;"></textarea>
    </div>
    <div class="form-row">
      <button onclick="sendGrayscaleData()"
        style="background-color:#4CAF50; color:white; padding:10px 20px; font-size:16px;">å‚³é€ç°éšåœ–ç‰‡è³‡æ–™</button>
      <button onclick="clearGrayscaleData()" style="margin-left:10px;">æ¸…é™¤æ•¸æ“š</button>
    </div>
    <div class="form-row">
      <small>ğŸ’¡ æç¤º: å¾å¤–éƒ¨åœ–ç‰‡è½‰æ›å·¥å…·è¤‡è£½æ•¸æ“šï¼Œè¨­å®šå¥½ä½ç½®å’Œå°ºå¯¸å¾Œé»æ“Šå‚³é€</small>
    </div>
  </div>


  <script>
    // ===== DOM å®‰å…¨è¨ªå•è¼”åŠ©å‡½æ•¸ =====
    function safeGetElement(id) {
      const element = document.getElementById(id);
      if (!element) {
        console.warn('Element not found:', id);
      }
      return element;
    }

    function safeGetValue(id, defaultValue = '') {
      const element = safeGetElement(id);
      return element ? element.value : defaultValue;
    }

    function safeSetValue(id, value) {
      const element = safeGetElement(id);
      if (element) {
        element.value = value;
        return true;
      }
      return false;
    }

    function safeSetText(id, text) {
      const element = safeGetElement(id);
      if (element) {
        element.textContent = text;
        return true;
      }
      return false;
    }

    // Canvas ç¹ªåœ–è®Šæ•¸
    let canvas = null;
    let ctx = null;
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let currentBrushSize = 3;
    let currentBrushColor = 0;

    // è·¯å¾‘è¨˜éŒ„è®Šæ•¸
    let strokePaths = [];
    let currentPath = null;

    // åˆå§‹åŒ– Canvas
    function initCanvas() {
      canvas = document.getElementById('drawingCanvas');
      ctx = canvas.getContext('2d');

      // è¨­ç½® canvas å¯¦éš›å°ºå¯¸èˆ‡é¡¯ç¤ºå°ºå¯¸
      const epdRatio = 960 / 540; // EPDçš„é«˜å¯¬æ¯”
      const containerWidth = Math.min(800, window.innerWidth - 100);
      canvas.style.width = containerWidth + 'px';
      canvas.style.height = (containerWidth * epdRatio) + 'px';

      // è¨­ç½®ç¹ªåœ–å±¬æ€§
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // è¨­ç½®é è¨­ç¹ªåœ–æ¨£å¼
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 3;

      console.log('Canvas initialized:', canvas.width, 'x', canvas.height);

      // æ»‘é¼ äº‹ä»¶
      canvas.addEventListener('mousedown', startDrawing);
      canvas.addEventListener('mousemove', draw);
      canvas.addEventListener('mouseup', stopDrawing);
      canvas.addEventListener('mouseout', stopDrawing);

      // è§¸æ§äº‹ä»¶
      canvas.addEventListener('touchstart', handleTouch);
      canvas.addEventListener('touchmove', handleTouch);
      canvas.addEventListener('touchend', stopDrawing);
    }

    function startDrawing(e) {
      isDrawing = true;
      [lastX, lastY] = getMousePos(e);

      // é–‹å§‹æ–°çš„è·¯å¾‘è¨˜éŒ„
      currentPath = {
        color: currentBrushColor,
        size: currentBrushSize,
        points: [[Math.round(lastX), Math.round(lastY)]]
      };
    }

    function draw(e) {
      if (!isDrawing) return;

      const [currentX, currentY] = getMousePos(e);

      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = getCanvasColor(currentBrushColor);
      ctx.lineWidth = currentBrushSize;

      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(currentX, currentY);
      ctx.stroke();

      // è¨˜éŒ„è·¯å¾‘é»
      if (currentPath) {
        currentPath.points.push([Math.round(currentX), Math.round(currentY)]);
      }

      [lastX, lastY] = [currentX, currentY];
    }

    function stopDrawing() {
      if (isDrawing && currentPath && currentPath.points.length > 1) {
        // å®Œæˆè·¯å¾‘è¨˜éŒ„
        strokePaths.push(currentPath);
        console.log('Path recorded:', currentPath);
      }
      isDrawing = false;
      currentPath = null;
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      return [
        (e.clientX - rect.left) * scaleX,
        (e.clientY - rect.top) * scaleY
      ];
    }

    function handleTouch(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' :
        e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    }

    function getCanvasColor(colorValue) {
      // å°‡ 0-15 çš„é¡è‰²å€¼è½‰æ›ç‚º canvas é¡è‰²
      // 0=é»‘è‰², 15=ç™½è‰²
      const gray = Math.round(colorValue * 255 / 15);
      return `rgb(${gray}, ${gray}, ${gray})`;
    }

    function clearCanvas() {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      console.log('Canvas cleared');
    }

    function updateBrushSize() {
      currentBrushSize = safeGetValue('brushSize');
      safeSetText('brushSizeValue', currentBrushSize);
    }

    function updateBrushColor() {
      currentBrushColor = safeGetValue('brushColor');
      const colorName = getColorName(currentBrushColor);
      safeSetText('brushColorValue', currentBrushColor + ' (' + colorName + ')');
    }

    function sendCanvasToEPD() {
      console.log('sendCanvasToEPD called');

      // æª¢æŸ¥ canvas æ˜¯å¦å·²åˆå§‹åŒ–
      if (!canvas || !ctx) {
        console.error('Canvas not initialized');
        alert('Canvas å°šæœªåˆå§‹åŒ–');
        return;
      }

      console.log('Canvas size:', canvas.width, 'x', canvas.height);
      console.log('Total recorded paths:', strokePaths.length);

      // å„ªå…ˆä½¿ç”¨è·¯å¾‘æ ¼å¼
      if (strokePaths.length > 0) {
        sendStrokePaths();
      } else {
        console.log('No paths recorded, using pixel analysis fallback');
        sendCanvasAsPixels();
      }
    }

    // ç™¼é€è·¯å¾‘æ•¸æ“š (å£“ç¸®æ ¼å¼)
    function sendStrokePaths() {
      console.log('Sending stroke paths');

      const pathStrings = [];
      for (let i = 0; i < strokePaths.length; i++) {
        const path = strokePaths[i];
        const pointsStr = path.points.map(p => p[0] + ',' + p[1]).join('|');
        const pathStr = 'P:' + path.color + ':' + path.size + ':' + pointsStr;
        pathStrings.push(pathStr);
      }

      const dataStr = pathStrings.join(';');
      console.log('Path data length:', dataStr.length);
      console.log('Path data preview:', dataStr.substring(0, 200));
      console.log('Path data ending:', dataStr.length > 100 ? dataStr.substring(dataStr.length - 100) : dataStr);
      console.log('Number of paths generated:', pathStrings.length);

      // æª¢æŸ¥æ¯å€‹è·¯å¾‘çš„å®Œæ•´æ€§
      for (let i = 0; i < Math.min(pathStrings.length, 3); i++) {
        console.log('Path', i, 'sample:', pathStrings[i].substring(0, 100));
      }

      // æª¢æŸ¥æ•¸æ“šå¤§å°
      if (dataStr.length > 50000) {
        console.warn('Path data too large:', dataStr.length, 'chars');
        alert('è­¦å‘Šï¼šè·¯å¾‘æ•¸æ“šéå¤§ (' + dataStr.length + ' å­—ç¬¦)ï¼Œè«‹æ¸›å°‘ç¹ªåœ–å…§å®¹ã€‚');
        return;
      }

      // æº–å‚™ POST æ•¸æ“š
      const postData = 'width=' + canvas.width + '&height=' + canvas.height + '&paths=1&data=' + encodeURIComponent(dataStr);
      console.log('POST data length:', postData.length);
      console.log('Encoded data preview (first 200):', postData.substring(0, 200));
      console.log('Encoded data ending (last 100):', postData.length > 100 ? postData.substring(postData.length - 100) : postData);

      // æª¢æŸ¥ POST æ•¸æ“šå¤§å°é™åˆ¶
      if (postData.length > 8000) {
        console.warn('POST data approaching ESP32 limits:', postData.length, 'chars');
        alert('è­¦å‘Šï¼šPOSTæ•¸æ“šæ¥è¿‘ESP32é™åˆ¶ (' + postData.length + ' å­—ç¬¦)ï¼Œå¯èƒ½æœƒè¢«æˆªæ–·ï¼');
        // ä»ç„¶å˜—è©¦ç™¼é€ï¼Œä½†ç”¨æˆ¶å·²è¢«è­¦å‘Š
      }

      // ç™¼é€åˆ°æœå‹™å™¨
      fetch('/draw/canvas', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: postData
      })
        .then(response => response.text())
        .then(data => {
          console.log('Response:', data);
          alert('è·¯å¾‘æ•¸æ“šå·²é€å‡ºï¼');
        })
        .catch(error => {
          console.error('Error:', error);
          alert('ç™¼é€å¤±æ•—ï¼š' + error);
        });
    }

    // åƒç´ åˆ†æå‚™ç”¨æ–¹æ¡ˆ
    function sendCanvasAsPixels() {

      // å°‡ canvas è½‰æ›ç‚ºåœ–åƒæ•¸æ“šä¸¦ç™¼é€åˆ° EPD
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pixelData = imageData.data;

      console.log('Canvas size:', canvas.width, 'x', canvas.height);
      console.log('Total pixels:', canvas.width * canvas.height);
      console.log('ImageData length:', pixelData.length);

      // ä½¿ç”¨å£“ç¸®æ ¼å¼ï¼šåªå‚³é€éç™½è‰²åƒç´ çš„ä½ç½®å’Œé¡è‰²
      const compressedData = [];
      for (let i = 0; i < pixelData.length; i += 4) {
        const gray = pixelData[i];
        const epdGray = Math.round(gray * 15 / 255);

        // åªè¨˜éŒ„éç™½è‰²åƒç´  (å€¼ä¸ç­‰æ–¼15)
        if (epdGray !== 15) {
          const pixelIndex = i / 4;
          const x = pixelIndex % canvas.width;
          const y = Math.floor(pixelIndex / canvas.width);
          compressedData.push(x + ',' + y + ',' + epdGray);
        }
      }

      console.log('Total pixels:', canvas.width * canvas.height);
      console.log('Non-white pixels:', compressedData.length);
      console.log('Compression ratio:', ((compressedData.length / (canvas.width * canvas.height)) * 100).toFixed(2) + '%');

      // å°‡å£“ç¸®æ•¸æ“šç·¨ç¢¼ç‚ºå­—ä¸²
      const dataStr = compressedData.join(';');

      console.log('Compressed data string length:', dataStr.length);
      console.log('First 100 chars of compressed data:', dataStr.substring(0, 100));

      // æª¢æŸ¥æ•¸æ“šå¤§å°
      if (dataStr.length > 10000) {
        console.warn('Warning: Compressed data still large:', dataStr.length, 'chars');
        if (dataStr.length > 50000) {
          alert('è­¦å‘Šï¼šå£“ç¸®å¾Œæ•¸æ“šä»éå¤§ (' + dataStr.length + ' å­—ç¬¦)ï¼Œè«‹æ¸›å°‘ç¹ªåœ–å…§å®¹ã€‚');
          return;
        }
      }

      // æº–å‚™ POST æ•¸æ“š (ä½¿ç”¨å£“ç¸®æ ¼å¼)
      const postData = 'width=' + canvas.width + '&height=' + canvas.height + '&compressed=1&data=' + encodeURIComponent(dataStr);
      console.log('POST data length:', postData.length);
      console.log('POST data preview:', postData.substring(0, 200));

      // æœ€çµ‚æ•¸æ“šå¤§å°æª¢æŸ¥
      if (postData.length > 20000) {
        console.error('POST data too large:', postData.length, 'chars');
        alert('éŒ¯èª¤ï¼šPOSTæ•¸æ“šéå¤§ (' + postData.length + ' å­—ç¬¦)ï¼Œè«‹æ¸›å°‘ç¹ªåœ–å…§å®¹ã€‚');
        return;
      }

      // ç™¼é€åˆ°æœå‹™å™¨
      fetch('/draw/canvas', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: postData
      })
        .then(response => {
          console.log('Response status:', response.status);
          console.log('Response headers:', response.headers);
          return response.text();
        })
        .then(data => {
          console.log('Server response:', data);
          alert('Canvas å·²åŒæ­¥åˆ° EPD: ' + data);
        })
        .catch(error => {
          console.error('Error:', error);
          alert('åŒæ­¥å¤±æ•—: ' + error.message);
        });
    }
    function updateTextColorValue() {
      const color = safeGetValue('textColor');
      if (!color) return;

      let colorName;
      if (color == 0) colorName = 'é»‘è‰²';
      else if (color <= 3) colorName = 'æ·±ç°';
      else if (color <= 7) colorName = 'ä¸­ç°';
      else if (color <= 11) colorName = 'æ·ºç°';
      else colorName = 'ç™½è‰²';

      safeSetText('textColorValue', color + ' (' + colorName + ')');
    }

    function updateBgColorValue() {
      const color = safeGetValue('bgColor');
      if (!color) return;

      let colorName;
      if (color == 16) {
        colorName = 'é€æ˜';
      } else {
        if (color == 0) colorName = 'é»‘è‰²';
        else if (color <= 3) colorName = 'æ·±ç°';
        else if (color <= 7) colorName = 'ä¸­ç°';
        else if (color <= 11) colorName = 'æ·ºç°';
        else colorName = 'ç™½è‰²';
        colorName = color + ' (' + colorName + ')';
      }

      safeSetText('bgColorValue', colorName);
    }

    function updateFontSizeValue() {
      const size = safeGetValue('fontSize');
      safeSetText('fontSizeValue', size + ' (åƒç´ å€æ•¸)');
    }

    function updateLineColorValue() {
      const color = safeGetValue('lineColor');
      if (!color) return;
      const colorName = getColorName(color);
      safeSetText('lineColorValue', color + ' (' + colorName + ')');
    }

    function updateLineThicknessValue() {
      const thickness = safeGetValue('lineThickness');
      if (!thickness) return;
      safeSetText('lineThicknessValue', thickness + ' åƒç´ ');
    }

    function updateCircleBorderColorValue() {
      const color = safeGetValue('circleBorderColor');
      if (!color) return;
      const colorName = getColorName(color);
      safeSetText('circleBorderColorValue', color + ' (' + colorName + ')');
    }

    function updateCircleBorderThicknessValue() {
      const thickness = safeGetValue('circleBorderThickness');
      if (!thickness) return;
      safeSetText('circleBorderThicknessValue', thickness + ' åƒç´ ');
    }

    function updateCircleFillColorValue() {
      const color = safeGetValue('circleFillColor');
      if (!color) return;
      const colorName = getColorName(color);
      safeSetText('circleFillColorValue', color + ' (' + colorName + ')');
    }

    function updateRectBorderColorValue() {
      const color = safeGetValue('rectBorderColor');
      if (!color) return;
      const colorName = getColorName(color);
      safeSetText('rectBorderColorValue', color + ' (' + colorName + ')');
    }

    function updateRectBorderThicknessValue() {
      const thickness = safeGetValue('rectBorderThickness');
      if (!thickness) return;
      safeSetText('rectBorderThicknessValue', thickness + ' åƒç´ ');
    }

    function updateRectFillColorValue() {
      const color = safeGetValue('rectFillColor');
      if (!color) return;
      const colorName = getColorName(color);
      safeSetText('rectFillColorValue', color + ' (' + colorName + ')');
    }

    function getColorName(color) {
      if (color == 0) return 'é»‘è‰²';
      else if (color <= 3) return 'æ·±ç°';
      else if (color <= 7) return 'ä¸­ç°';
      else if (color <= 11) return 'æ·ºç°';
      else return 'ç™½è‰²';
    }

    function setStyle(styleName) {
      const styles = {
        'title': { fontSize: 4, textColor: 0, bgColor: 16 },      // å¤§å­—é»‘è‰²ï¼Œé€æ˜èƒŒæ™¯
        'normal': { fontSize: 2, textColor: 0, bgColor: 16 },     // ä¸­å­—é»‘è‰²ï¼Œé€æ˜èƒŒæ™¯
        'highlight': { fontSize: 3, textColor: 15, bgColor: 0 },  // å¤§å­—ç™½è‰²ï¼Œé»‘è‰²èƒŒæ™¯
        'subtitle': { fontSize: 3, textColor: 5, bgColor: 16 }    // å¤§å­—ç°è‰²ï¼Œé€æ˜èƒŒæ™¯
      };

      if (styles[styleName]) {
        document.getElementById('fontSize').value = styles[styleName].fontSize;
        document.getElementById('textColor').value = styles[styleName].textColor;
        document.getElementById('bgColor').value = styles[styleName].bgColor;

        // æ›´æ–°é¡¯ç¤ºå€¼
        updateFontSizeValue();
        updateTextColorValue();
        updateBgColorValue();
      }
    }

    function drawText() {
      const text = document.getElementById('text').value;
      const x = document.getElementById('x').value;
      const y = document.getElementById('y').value;
      const textColor = document.getElementById('textColor').value;
      const bgColor = document.getElementById('bgColor').value;
      const fontSize = document.getElementById('fontSize').value;

      if (!text.trim()) {
        alert('è«‹è¼¸å…¥æ–‡å­—');
        return;
      }

      // 16 è¡¨ç¤ºé€æ˜èƒŒæ™¯ï¼Œè½‰æ›ç‚º 255
      const actualBgColor = bgColor == 16 ? 255 : bgColor;

      const url = '/draw/text?text=' + encodeURIComponent(text) +
        '&x=' + x + '&y=' + y +
        '&textColor=' + textColor + '&bgColor=' + actualBgColor +
        '&fontSize=' + fontSize;

      fetch(url)
        .then(response => response.text())
        .then(data => {
          console.log(data);

        })
        .catch(error => {
          console.error('Error:', error);
          alert('ç¹ªè£½å¤±æ•—');
        });
    }

    function drawMultiText() {
      const texts = document.getElementById('multiText').value;
      const startX = document.getElementById('startX').value;
      const startY = document.getElementById('startY').value;
      const lineHeight = document.getElementById('lineHeight').value;
      const textColor = document.getElementById('textColor').value;
      const bgColor = document.getElementById('bgColor').value;
      const fontSize = document.getElementById('fontSize').value;

      if (!texts.trim()) {
        alert('è«‹è¼¸å…¥å¤šè¡Œæ–‡å­—');
        return;
      }

      // 16 è¡¨ç¤ºé€æ˜èƒŒæ™¯ï¼Œè½‰æ›ç‚º 255
      const actualBgColor = bgColor == 16 ? 255 : bgColor;

      const url = '/draw/multitext?texts=' + encodeURIComponent(texts) +
        '&startX=' + startX + '&startY=' + startY +
        '&lineHeight=' + lineHeight +
        '&textColor=' + textColor + '&bgColor=' + actualBgColor +
        '&fontSize=' + fontSize;

      fetch(url)
        .then(response => response.text())
        .then(data => {
          console.log(data);
          alert('å¤šè¡Œæ–‡å­—å·²ç¹ªè£½: ' + data);
        })
        .catch(error => {
          console.error('Error:', error);
          alert('ç¹ªè£½å¤±æ•—');
        });
    }

    function drawLineAdvanced() {
      const x1 = document.getElementById('lineX1').value;
      const y1 = document.getElementById('lineY1').value;
      const x2 = document.getElementById('lineX2').value;
      const y2 = document.getElementById('lineY2').value;
      const color = document.getElementById('lineColor').value;
      const thickness = document.getElementById('lineThickness').value;

      const url = '/draw/line/advanced?x1=' + x1 + '&y1=' + y1 +
        '&x2=' + x2 + '&y2=' + y2 +
        '&color=' + color + '&thickness=' + thickness;

      fetch(url)
        .then(response => response.text())
        .then(data => {
          console.log(data);
          alert('ç·šæ¢å·²ç¹ªè£½: ' + data);
        })
        .catch(error => {
          console.error('Error:', error);
          alert('ç¹ªè£½å¤±æ•—');
        });
    }

    function drawCircleAdvanced() {
      const centerX = document.getElementById('circleX').value;
      const centerY = document.getElementById('circleY').value;
      const radius = document.getElementById('circleRadius').value;
      const hasBorder = document.getElementById('circleBorder').checked;
      const borderColor = document.getElementById('circleBorderColor').value;
      const borderThickness = document.getElementById('circleBorderThickness').value;
      const isFilled = document.getElementById('circleFill').checked;
      const fillColor = document.getElementById('circleFillColor').value;

      const url = '/draw/circle/advanced?centerX=' + centerX + '&centerY=' + centerY +
        '&radius=' + radius + '&hasBorder=' + hasBorder +
        '&borderColor=' + borderColor + '&borderThickness=' + borderThickness +
        '&isFilled=' + isFilled + '&fillColor=' + fillColor;

      fetch(url)
        .then(response => response.text())
        .then(data => {
          console.log(data);
          alert('åœ“å½¢å·²ç¹ªè£½: ' + data);
        })
        .catch(error => {
          console.error('Error:', error);
          alert('ç¹ªè£½å¤±æ•—');
        });
    }

    function drawRectAdvanced() {
      const x = document.getElementById('rectX').value;
      const y = document.getElementById('rectY').value;
      const width = document.getElementById('rectWidth').value;
      const height = document.getElementById('rectHeight').value;
      const hasBorder = document.getElementById('rectBorder').checked;
      const borderColor = document.getElementById('rectBorderColor').value;
      const borderThickness = document.getElementById('rectBorderThickness').value;
      const isFilled = document.getElementById('rectFill').checked;
      const fillColor = document.getElementById('rectFillColor').value;

      const url = '/draw/rect/advanced?x=' + x + '&y=' + y +
        '&width=' + width + '&height=' + height +
        '&hasBorder=' + hasBorder + '&borderColor=' + borderColor +
        '&borderThickness=' + borderThickness +
        '&isFilled=' + isFilled + '&fillColor=' + fillColor;

      fetch(url)
        .then(response => response.text())
        .then(data => {
          console.log(data);
          alert('çŸ©å½¢å·²ç¹ªè£½: ' + data);
        })
        .catch(error => {
          console.error('Error:', error);
          alert('ç¹ªè£½å¤±æ•—');
        });
    }

    // åˆå§‹åŒ–æ‰€æœ‰é¡¯ç¤ºå€¼
    function initializeValues() {
      updateTextColorValue();
      updateBgColorValue();
      updateFontSizeValue();
      updateLineColorValue();
      updateLineThicknessValue();
      updateCircleBorderColorValue();
      updateCircleBorderThicknessValue();
      updateCircleFillColorValue();
      updateRectBorderColorValue();
      updateRectBorderThicknessValue();
      updateRectFillColorValue();
      updateBrushSize();
      updateBrushColor();
    }

    // ç°éšæ•¸æ“šå‚³é€å‡½æ•¸
    function sendGrayscaleData() {
      const x = document.getElementById('grayscaleX').value;
      const y = document.getElementById('grayscaleY').value;
      const width = document.getElementById('grayscaleWidth').value;
      const height = document.getElementById('grayscaleHeight').value;
      const data = document.getElementById('grayscaleData').value.trim();

      // é©—è­‰è¼¸å…¥
      if (!data) {
        alert('è«‹è¼¸å…¥ç°éšæ•¸æ“šï¼');
        return;
      }

      if (parseInt(width) <= 0 || parseInt(height) <= 0) {
        alert('å¯¬åº¦å’Œé«˜åº¦å¿…é ˆå¤§æ–¼0ï¼');
        return;
      }

      // æª¢æŸ¥æ•¸æ“šæ ¼å¼
      const values = data.split(',').map(v => v.trim()).filter(v => v !== '');
      const expectedCount = parseInt(width) * parseInt(height);

      if (values.length !== expectedCount) {
        alert(`æ•¸æ“šé»æ•¸ä¸ç¬¦ï¼é æœŸ: ${expectedCount} å€‹ï¼Œå¯¦éš›: ${values.length} å€‹`);
        return;
      }

      // æª¢æŸ¥æ•¸å€¼ç¯„åœ
      for (let i = 0; i < values.length; i++) {
        const val = parseInt(values[i]);
        if (isNaN(val) || val < 0 || val > 15) {
          alert(`ç¬¬ ${i + 1} å€‹æ•¸å€¼ç„¡æ•ˆ: "${values[i]}"ï¼Œæ‡‰è©²æ˜¯ 0-15 ä¹‹é–“çš„æ•´æ•¸`);
          return;
        }
      }

      console.log('Sending grayscale data:', { x, y, width, height, dataLength: values.length });

      // æº–å‚™ç™¼é€æ•¸æ“š
      const formData = new FormData();
      formData.append('x', x);
      formData.append('y', y);
      formData.append('width', width);
      formData.append('height', height);
      formData.append('data', data);

      // ç™¼é€åˆ°ä¼ºæœå™¨
      fetch('/draw/grayscale', {
        method: 'POST',
        body: formData
      })
        .then(response => response.text())
        .then(result => {
          console.log('Grayscale data sent successfully:', result);
          alert('ç°éšåœ–ç‰‡å·²æˆåŠŸé¡¯ç¤ºåœ¨EPDä¸Šï¼');
        })
        .catch(error => {
          console.error('Error sending grayscale data:', error);
          alert('å‚³é€å¤±æ•—: ' + error.message);
        });
    }

    function clearGrayscaleData() {
      document.getElementById('grayscaleData').value = '';
      document.getElementById('grayscaleX').value = '0';
      document.getElementById('grayscaleY').value = '0';
      document.getElementById('grayscaleWidth').value = '100';
      document.getElementById('grayscaleHeight').value = '100';
    }

    // åˆå§‹åŒ– Canvas
    window.onload = function () {
      console.log('Window loaded, initializing...');
      initCanvas();
      initImageConverter();
      initImageControls();
      initializeValues();
      console.log('All systems initialized');
    };

    // ===== åœ–ç‰‡è½‰æ›å™¨åŠŸèƒ½ =====
    let currentWidth = 480;
    let currentHeight = 800;
    let imageCanvas = null;
    let imageCtx = null;
    let currentImageData = null;

    function initImageConverter() {
      imageCanvas = document.getElementById('imageCanvas');
      imageCtx = imageCanvas.getContext('2d');

      // è¨­ç½®åˆå§‹ç•«å¸ƒ
      resetImageCanvas();

      // ç¶å®šäº‹ä»¶
      document.getElementById('imageInput').addEventListener('change', handleImageUpload);
      document.getElementById('widthSelect').addEventListener('change', updateCanvasSize);
      document.getElementById('heightSelect').addEventListener('change', updateCanvasSize);
      document.getElementById('converterDataTextarea').addEventListener('dblclick', copyConverterData);
    }

    function updateCanvasSize() {
      currentWidth = parseInt(document.getElementById('widthSelect').value);
      currentHeight = parseInt(document.getElementById('heightSelect').value);

      // æ›´æ–°ç•«å¸ƒå°ºå¯¸
      imageCanvas.width = currentWidth;
      imageCanvas.height = currentHeight;

      // æ›´æ–°æ¨™ç±¤
      const totalPixels = currentWidth * currentHeight;
      document.getElementById('dataLabel').textContent =
        `ç°éšæ•¸æ“š (${currentWidth}Ã—${currentHeight} = ${totalPixels.toLocaleString()} å€‹å€¼)ï¼š`;

      // é‡ç½®ç•«å¸ƒ
      resetImageCanvas();

      // æ›´æ–°é è¨­æŒ‰éˆ•ç‹€æ…‹
      updatePresetButtons();
    }

    function setPresetSize(width, height) {
      document.getElementById('widthSelect').value = width;
      document.getElementById('heightSelect').value = height;
      updateCanvasSize();
    }

    function updatePresetButtons() {
      const presetButtons = document.querySelectorAll('.preset-btn');
      presetButtons.forEach(btn => btn.classList.remove('active'));

      // æª¢æŸ¥æ˜¯å¦ç¬¦åˆé è¨­å°ºå¯¸
      if (currentWidth === 64 && currentHeight === 64) {
        presetButtons[0].classList.add('active');
      } else if (currentWidth === 128 && currentHeight === 128) {
        presetButtons[1].classList.add('active');
      } else if (currentWidth === 320 && currentHeight === 240) {
        presetButtons[2].classList.add('active');
      } else if (currentWidth === 480 && currentHeight === 800) {
        presetButtons[3].classList.add('active');
      } else if (currentWidth === 540 && currentHeight === 960) {
        presetButtons[4].classList.add('active');
      } else if (currentWidth === 800 && currentHeight === 600) {
        presetButtons[5].classList.add('active');
      }
    }

    function handleImageUpload(e) {
      const file = e.target.files[0];
      if (file) {
        processImage(file);
      }
    }

    function processImage(file) {
      const reader = new FileReader();

      reader.onload = function (e) {
        const img = new Image();

        img.onload = function () {
          // æ¸…é™¤ç•«å¸ƒ
          resetImageCanvas();

          // ç¹ªè£½ä¸¦ç¸®æ”¾åœ–ç‰‡åˆ°æŒ‡å®šå°ºå¯¸
          imageCtx.drawImage(img, 0, 0, currentWidth, currentHeight);

          // ç²å–åœ–ç‰‡æ•¸æ“š
          const imageData = imageCtx.getImageData(0, 0, currentWidth, currentHeight);

          // è½‰æ›ç‚ºç°éš
          const grayscaleData = convertToGrayscale(imageData);

          // é‡æ–°ç¹ªè£½ç°éšåœ–ç‰‡
          drawGrayscaleImageToCanvas(grayscaleData);

          // è½‰æ›ç‚ºæ•¸æ“šæ ¼å¼
          const dataString = grayscaleData.join(',');
          document.getElementById('converterDataTextarea').value = dataString;
          currentImageData = dataString;

          // æ›´æ–°è³‡è¨Š
          document.getElementById('canvasInfo').innerHTML =
            `<strong>åœ–ç‰‡è³‡è¨Šï¼š</strong><br>
             åŸå§‹å°ºå¯¸: ${img.width} Ã— ${img.height}<br>
             è½‰æ›å°ºå¯¸: ${currentWidth} Ã— ${currentHeight}<br>
             æ•¸æ“šé»æ•¸: ${grayscaleData.length.toLocaleString()}<br>
             æª”æ¡ˆå¤§å°: ${(file.size / 1024).toFixed(1)} KB`;

          showToast('åœ–ç‰‡è½‰æ›å®Œæˆï¼');
        };

        img.src = e.target.result;
      };

      reader.readAsDataURL(file);
    }

    function convertToGrayscale(imageData) {
      const data = imageData.data;
      const grayscaleData = [];

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        // ä½¿ç”¨æ¨™æº–ç°éšè½‰æ›å…¬å¼
        const gray = 0.299 * r + 0.587 * g + 0.114 * b;

        // è½‰æ›ç‚º 0-15 ç¯„åœ (EPD 4-bit ç°éš)
        const grayscaleValue = Math.round((gray / 255) * 15);
        grayscaleData.push(grayscaleValue);
      }

      return grayscaleData;
    }

    function drawGrayscaleImageToCanvas(grayscaleData) {
      const imageData = imageCtx.createImageData(currentWidth, currentHeight);
      const data = imageData.data;

      for (let i = 0; i < grayscaleData.length; i++) {
        const grayValue = Math.round((grayscaleData[i] / 15) * 255);
        const pixelIndex = i * 4;

        data[pixelIndex] = grayValue;     // R
        data[pixelIndex + 1] = grayValue; // G
        data[pixelIndex + 2] = grayValue; // B
        data[pixelIndex + 3] = 255;       // A
      }

      imageCtx.putImageData(imageData, 0, 0);
    }

    function resetImageCanvas() {
      imageCtx.fillStyle = '#ffffff';
      imageCtx.fillRect(0, 0, currentWidth, currentHeight);
    }

    function copyConverterData() {
      const textarea = document.getElementById('converterDataTextarea');
      textarea.select();
      textarea.setSelectionRange(0, 99999);

      try {
        document.execCommand('copy');
        showToast('æ•¸æ“šå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼');
      } catch (err) {
        navigator.clipboard.writeText(textarea.value).then(() => {
          showToast('æ•¸æ“šå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼');
        }).catch(() => {
          showToast('è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•é¸å–è¤‡è£½');
        });
      }
    }

    function resetConverter() {
      document.getElementById('converterDataTextarea').value = '';
      document.getElementById('canvasInfo').textContent = 'è«‹å…ˆé¸æ“‡åœ–ç‰‡æª”æ¡ˆ';
      document.getElementById('imageInput').value = '';
      currentImageData = null;
      resetImageCanvas();
    }

    function downloadConverterData() {
      if (currentImageData) {
        const blob = new Blob([currentImageData], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `epd_grayscale_data_${currentWidth}x${currentHeight}_${new Date().getTime()}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('æ•¸æ“šæª”æ¡ˆä¸‹è¼‰å®Œæˆï¼');
      } else {
        showToast('è«‹å…ˆè½‰æ›åœ–ç‰‡ï¼');
      }
    }

    function showToast(message) {
      const toast = document.createElement('div');
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 10px 20px;
        border-radius: 4px;
        z-index: 1000;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        transition: opacity 0.3s;
      `;

      document.body.appendChild(toast);

      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => {
          document.body.removeChild(toast);
        }, 300);
      }, 3000);
    }

    // ===== æ™ºèƒ½åœ–ç‰‡æ§åˆ¶ç³»çµ± =====
    let originalImageData = null;
    let previewCanvas = null;
    let previewCtx = null;
    let currentImageFile = null;

    // åˆå§‹åŒ–åœ–ç‰‡æ§åˆ¶ç³»çµ±
    function initImageControls() {
      previewCanvas = document.getElementById('imagePreviewCanvas');
      if (previewCanvas) {
        previewCtx = previewCanvas.getContext('2d');
        // è¨­å®šç•«å¸ƒå¤§å°æ¯”ä¾‹ (EPD: 540x960)
        previewCanvas.width = 270;  // 1:2 ç¸®æ”¾é è¦½
        previewCanvas.height = 480;
      }
    }

    // åœ–ç‰‡ä¸Šå‚³é è¦½
    function previewUploadedImage() {
      const fileInput = document.getElementById('uploadImageFile');
      const file = fileInput.files[0];

      if (!file) {
        showToast('è«‹é¸æ“‡åœ–ç‰‡æª”æ¡ˆ');
        return;
      }

      // æª¢æŸ¥æª”æ¡ˆé¡å‹
      if (!file.type.startsWith('image/')) {
        showToast('è«‹é¸æ“‡æœ‰æ•ˆçš„åœ–ç‰‡æª”æ¡ˆ');
        return;
      }

      currentImageFile = file;
      const reader = new FileReader();

      reader.onload = function (e) {
        const img = new Image();
        img.onload = function () {
          originalImageData = {
            image: img,
            width: img.width,
            height: img.height
          };

          // é¡¯ç¤ºåœ–ç‰‡è³‡è¨Š
          document.getElementById('imageInfo').textContent =
            `åŸå§‹å°ºå¯¸: ${img.width} Ã— ${img.height} åƒç´ `;

          // è‡ªå‹•è¨­å®šåˆç†çš„å°ºå¯¸
          const maxWidth = Math.min(img.width, 540);
          const maxHeight = Math.min(img.height, 960);
          const aspectRatio = img.width / img.height;

          let newWidth = maxWidth;
          let newHeight = Math.round(newWidth / aspectRatio);

          if (newHeight > maxHeight) {
            newHeight = maxHeight;
            newWidth = Math.round(newHeight * aspectRatio);
          }

          document.getElementById('imgX').value = Math.max(0, Math.floor((540 - newWidth) / 2));
          document.getElementById('imgY').value = Math.max(0, Math.floor((960 - newHeight) / 2));
          document.getElementById('imgWidth').value = newWidth;
          document.getElementById('imgHeight').value = newHeight;

          // é¡¯ç¤ºé è¦½å€åŸŸ
          document.getElementById('imagePreview').style.display = 'block';
          document.getElementById('sendImageBtn').disabled = false;

          // é¡¯ç¤ºæ§åˆ¶å€åŸŸ
          showImageControls();

          updateImagePreview();
          showToast('åœ–ç‰‡è¼‰å…¥æˆåŠŸï¼');
        };
        img.src = e.target.result;
      };

      reader.onerror = function () {
        showToast('åœ–ç‰‡è®€å–å¤±æ•—ï¼Œè«‹é‡æ–°é¸æ“‡');
      };

      reader.readAsDataURL(file);
    }

    // æ›´æ–°åœ–ç‰‡é è¦½
    function updateImagePreview() {
      if (!originalImageData || !previewCanvas) return;

      const x = parseInt(document.getElementById('imgX').value) || 0;
      const y = parseInt(document.getElementById('imgY').value) || 0;
      const width = parseInt(document.getElementById('imgWidth').value) || 100;
      const height = parseInt(document.getElementById('imgHeight').value) || 100;

      // æ¸…é™¤ç•«å¸ƒ
      previewCtx.fillStyle = 'white';
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

      // ç¹ªè£½ EPD é‚Šç•Œ
      previewCtx.strokeStyle = '#ccc';
      previewCtx.lineWidth = 1;
      previewCtx.strokeRect(0, 0, previewCanvas.width, previewCanvas.height);

      // è¨ˆç®—é è¦½ç¸®æ”¾æ¯”ä¾‹
      const scaleX = previewCanvas.width / 540;
      const scaleY = previewCanvas.height / 960;

      // ç¹ªè£½åœ–ç‰‡é è¦½
      try {
        previewCtx.drawImage(
          originalImageData.image,
          x * scaleX, y * scaleY,
          width * scaleX, height * scaleY
        );

        // æ‡‰ç”¨åœ–ç‰‡æ•ˆæœ
        applyImageEffects();

        // æ›´æ–°ä½ç½®è³‡è¨Š
        document.getElementById('positionInfo').textContent =
          `ä½ç½®: (${x}, ${y}), å°ºå¯¸: ${width} Ã— ${height}`;

      } catch (error) {
        console.error('é è¦½æ›´æ–°å¤±æ•—:', error);
        showToast('é è¦½æ›´æ–°å¤±æ•—');
      }
    }

    // æ‡‰ç”¨åœ–ç‰‡æ•ˆæœ
    function applyImageEffects() {
      if (!previewCanvas) return;

      const imageData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);
      const data = imageData.data;

      const contrast = parseFloat(document.getElementById('contrast').value) / 100;
      const brightness = parseInt(document.getElementById('brightness').value);
      const grayLevels = parseInt(document.getElementById('grayLevels').value);

      for (let i = 0; i < data.length; i += 4) {
        // è½‰æ›ç‚ºç°éš
        let gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;

        // èª¿æ•´äº®åº¦å’Œå°æ¯”åº¦
        gray = (gray - 128) * contrast + 128 + brightness;
        gray = Math.max(0, Math.min(255, gray));

        // é‡åŒ–åˆ°æŒ‡å®šç°éšç´šæ•¸
        const level = Math.floor(gray / (256 / grayLevels));
        gray = Math.round((level * 255) / (grayLevels - 1));

        data[i] = data[i + 1] = data[i + 2] = gray;
      }

      previewCtx.putImageData(imageData, 0, 0);
    }

    // ===== éšæ®µ2ï¼šåƒæ•¸æ§åˆ¶å’Œæ•ˆæœèª¿æ•´å‡½æ•¸ =====

    // è¼”åŠ©åŠŸèƒ½ï¼šé©æ‡‰è¢å¹•
    function fitToScreen() {
      if (!originalImageData) {
        showToast('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
        return;
      }

      document.getElementById('imgX').value = 0;
      document.getElementById('imgY').value = 0;
      document.getElementById('imgWidth').value = 540;
      document.getElementById('imgHeight').value = 960;
      updateImagePreview();
      showToast('å·²èª¿æ•´ç‚ºå…¨è¢å¹•é¡¯ç¤º');
    }

    // è¼”åŠ©åŠŸèƒ½ï¼šä¿æŒå¯¬é«˜æ¯”ä¾‹
    function keepAspectRatio() {
      if (!originalImageData) {
        showToast('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
        return;
      }

      const targetWidth = parseInt(document.getElementById('imgWidth').value);
      const aspectRatio = originalImageData.height / originalImageData.width;
      const newHeight = Math.round(targetWidth * aspectRatio);

      if (newHeight <= 960) {
        document.getElementById('imgHeight').value = newHeight;
      } else {
        // å¦‚æœé«˜åº¦è¶…å‡ºï¼Œå‰‡åŸºæ–¼é«˜åº¦è¨ˆç®—å¯¬åº¦
        const targetHeight = 960;
        const newWidth = Math.round(targetHeight / aspectRatio);
        document.getElementById('imgWidth').value = newWidth;
        document.getElementById('imgHeight').value = targetHeight;
      }

      updateImagePreview();
      showToast('å·²èª¿æ•´ç‚ºæ­£ç¢ºæ¯”ä¾‹');
    }

    // è¼”åŠ©åŠŸèƒ½ï¼šåœ–ç‰‡ç½®ä¸­
    function centerImage() {
      const width = parseInt(document.getElementById('imgWidth').value);
      const height = parseInt(document.getElementById('imgHeight').value);

      const centerX = Math.max(0, Math.floor((540 - width) / 2));
      const centerY = Math.max(0, Math.floor((960 - height) / 2));

      document.getElementById('imgX').value = centerX;
      document.getElementById('imgY').value = centerY;
      updateImagePreview();
      showToast('åœ–ç‰‡å·²ç½®ä¸­');
    }

    // æ•ˆæœæ§åˆ¶ï¼šå°æ¯”åº¦æ›´æ–°
    function updateContrast() {
      const value = document.getElementById('contrast').value;
      document.getElementById('contrastValue').textContent = value + '%';
      updateImagePreview();
    }

    // æ•ˆæœæ§åˆ¶ï¼šäº®åº¦æ›´æ–°
    function updateBrightness() {
      const value = document.getElementById('brightness').value;
      document.getElementById('brightnessValue').textContent = value;
      updateImagePreview();
    }

    // æ•ˆæœæ§åˆ¶ï¼šç°éšç´šæ•¸æ›´æ–°
    function updateGrayLevels() {
      const value = document.getElementById('grayLevels').value;
      document.getElementById('grayLevelsValue').textContent = value + 'ç´š';
      updateImagePreview();
    }

    // æ•ˆæœæ§åˆ¶ï¼šé¡è‰²åç›¸
    function invertColors() {
      if (!originalImageData) {
        showToast('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
        return;
      }

      // åˆ‡æ›åç›¸ç‹€æ…‹
      const isInverted = document.getElementById('contrast').dataset.inverted === 'true';

      if (!isInverted) {
        // è¨­å®šåç›¸æ•ˆæœ
        document.getElementById('contrast').value = 100;
        document.getElementById('brightness').value = 0;
        document.getElementById('contrast').dataset.inverted = 'true';
        showToast('å·²å¥—ç”¨åç›¸æ•ˆæœ');
      } else {
        // å–æ¶ˆåç›¸æ•ˆæœ
        document.getElementById('contrast').dataset.inverted = 'false';
        showToast('å·²å–æ¶ˆåç›¸æ•ˆæœ');
      }

      updateContrast();
      updateBrightness();
      updateImagePreview();
    }

    // æ•ˆæœæ§åˆ¶ï¼šé‡ç½®æ‰€æœ‰æ•ˆæœ
    function resetEffects() {
      document.getElementById('contrast').value = 100;
      document.getElementById('brightness').value = 0;
      document.getElementById('grayLevels').value = 16;
      document.getElementById('contrast').dataset.inverted = 'false';

      updateContrast();
      updateBrightness();
      updateGrayLevels();
      updateImagePreview();
      showToast('æ•ˆæœå·²é‡ç½®');
    }

    // é¡¯ç¤ºæ§åˆ¶å€åŸŸ
    function showImageControls() {
      document.getElementById('positionControls').style.display = 'block';
      document.getElementById('effectControls').style.display = 'block';
    }

    // éš±è—æ§åˆ¶å€åŸŸ
    function hideImageControls() {
      document.getElementById('positionControls').style.display = 'none';
      document.getElementById('effectControls').style.display = 'none';
    }

    // æ›´æ–°é è¦½å‡½æ•¸ï¼ˆæ”¹é€²ç‰ˆï¼‰
    function updateImagePreview() {
      if (!originalImageData || !previewCanvas) return;

      // é¡¯ç¤ºæ§åˆ¶å€åŸŸ
      showImageControls();

      const x = parseInt(document.getElementById('imgX').value) || 0;
      const y = parseInt(document.getElementById('imgY').value) || 0;
      const width = parseInt(document.getElementById('imgWidth').value) || 100;
      const height = parseInt(document.getElementById('imgHeight').value) || 100;

      // åƒæ•¸é©—è­‰
      if (x + width > 540) {
        document.getElementById('imgWidth').value = 540 - x;
        showToast('å¯¬åº¦å·²è‡ªå‹•èª¿æ•´ä»¥é©æ‡‰è¢å¹•');
        return;
      }

      if (y + height > 960) {
        document.getElementById('imgHeight').value = 960 - y;
        showToast('é«˜åº¦å·²è‡ªå‹•èª¿æ•´ä»¥é©æ‡‰è¢å¹•');
        return;
      }

      // æ¸…é™¤ç•«å¸ƒ
      previewCtx.fillStyle = 'white';
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

      // ç¹ªè£½ EPD é‚Šç•Œç·š
      previewCtx.strokeStyle = '#ccc';
      previewCtx.lineWidth = 1;
      previewCtx.strokeRect(0, 0, previewCanvas.width, previewCanvas.height);

      // è¨ˆç®—é è¦½ç¸®æ”¾æ¯”ä¾‹
      const scaleX = previewCanvas.width / 540;
      const scaleY = previewCanvas.height / 960;

      // ç¹ªè£½åœ–ç‰‡é è¦½
      try {
        previewCtx.drawImage(
          originalImageData.image,
          x * scaleX, y * scaleY,
          width * scaleX, height * scaleY
        );

        // æ‡‰ç”¨åœ–ç‰‡æ•ˆæœ
        applyImageEffects();

        // ç¹ªè£½ä½ç½®æŒ‡ç¤ºæ¡†
        previewCtx.strokeStyle = '#ff4444';
        previewCtx.lineWidth = 2;
        previewCtx.strokeRect(
          x * scaleX, y * scaleY,
          width * scaleX, height * scaleY
        );

        // æ›´æ–°ä½ç½®è³‡è¨Š
        document.getElementById('positionInfo').textContent =
          `ä½ç½®: (${x}, ${y}), å°ºå¯¸: ${width} Ã— ${height} åƒç´ `;

      } catch (error) {
        console.error('é è¦½æ›´æ–°å¤±æ•—:', error);
        showToast('é è¦½æ›´æ–°å¤±æ•—ï¼š' + error.message);
      }
    }

    // ===== éšæ®µ3ï¼šåœ–ç‰‡è³‡æ–™æº–å‚™å’Œç™¼é€ =====

    // ç™¼é€åœ–ç‰‡åˆ°EPD
    async function sendImageToEPD() {
      if (!originalImageData) {
        showToast('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
        return;
      }

      const btn = document.getElementById('sendImageBtn');
      const progress = document.getElementById('uploadProgress');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');

      btn.disabled = true;
      progress.style.display = 'block';
      progressBar.style.width = '0%';
      progressText.textContent = '0%';

      try {
        // æº–å‚™åœ–ç‰‡è³‡æ–™
        progressText.textContent = 'æ­£åœ¨è™•ç†åœ–ç‰‡...';
        progressBar.style.width = '10%';

        const imageData = await prepareImageData();
        if (!imageData) {
          throw new Error('åœ–ç‰‡è³‡æ–™è™•ç†å¤±æ•—');
        }

        progressText.textContent = 'æ­£åœ¨å‚³è¼¸è³‡æ–™...';
        progressBar.style.width = '30%';

        // ç™¼é€åˆ°Arduino
        const response = await fetch('/upload-image', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(imageData)
        });

        progressBar.style.width = '80%';
        progressText.textContent = 'æ­£åœ¨æ¸²æŸ“åˆ°EPD...';

        if (response.ok) {
          const result = await response.text();
          progressBar.style.width = '100%';
          progressText.textContent = 'å®Œæˆï¼';
          showToast('åœ–ç‰‡å·²æˆåŠŸç™¼é€åˆ°EPDï¼');
          console.log('Server response:', result);
        } else {
          throw new Error(`ä¼ºæœå™¨éŒ¯èª¤: ${response.status}`);
        }

      } catch (error) {
        console.error('ç™¼é€å¤±æ•—:', error);
        showToast('ç™¼é€å¤±æ•—: ' + error.message);
        progressBar.style.width = '0%';
        progressText.textContent = 'ç™¼é€å¤±æ•—';
      } finally {
        setTimeout(() => {
          btn.disabled = false;
          progress.style.display = 'none';
        }, 3000);
      }
    }

    // æº–å‚™åœ–ç‰‡è³‡æ–™
    async function prepareImageData() {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        const x = parseInt(document.getElementById('imgX').value) || 0;
        const y = parseInt(document.getElementById('imgY').value) || 0;
        const width = parseInt(document.getElementById('imgWidth').value) || 100;
        const height = parseInt(document.getElementById('imgHeight').value) || 100;

        canvas.width = width;
        canvas.height = height;

        // ç¹ªè£½èª¿æ•´å¾Œçš„åœ–ç‰‡
        ctx.drawImage(originalImageData.image, 0, 0, width, height);

        // ç²å–åœ–ç‰‡è³‡æ–™ä¸¦æ‡‰ç”¨æ•ˆæœ
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        const contrast = parseFloat(document.getElementById('contrast').value) / 100;
        const brightness = parseInt(document.getElementById('brightness').value);
        const grayLevels = parseInt(document.getElementById('grayLevels').value);
        const isInverted = document.getElementById('contrast').dataset.inverted === 'true';

        const grayData = [];

        // é€åƒç´ è™•ç†
        for (let i = 0; i < data.length; i += 4) {
          // è½‰æ›ç‚ºç°éš
          let gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;

          // èª¿æ•´äº®åº¦å’Œå°æ¯”åº¦
          gray = (gray - 128) * contrast + 128 + brightness;
          gray = Math.max(0, Math.min(255, gray));

          // åç›¸è™•ç†
          if (isInverted) {
            gray = 255 - gray;
          }

          // é‡åŒ–åˆ°æŒ‡å®šç°éšç´šæ•¸
          const level = Math.floor(gray / (256 / grayLevels));
          const finalGray = Math.round((level * 15) / (grayLevels - 1));

          grayData.push(Math.max(0, Math.min(15, finalGray)));
        }

        return {
          x: x,
          y: y,
          width: width,
          height: height,
          grayData: grayData,
          contrast: contrast,
          brightness: brightness,
          grayLevels: grayLevels,
          inverted: isInverted,
          filename: currentImageFile ? currentImageFile.name : 'unknown',
          filesize: currentImageFile ? currentImageFile.size : 0
        };

      } catch (error) {
        console.error('åœ–ç‰‡è³‡æ–™æº–å‚™å¤±æ•—:', error);
        return null;
      }
    }


    // æ™ºèƒ½åœ–ç‰‡æ§åˆ¶è®Šæ•¸
    var smartImageData = null;
    var originalImage = null;

    // åˆå§‹åŒ–åœ–ç‰‡æ§åˆ¶
    function initImageControls() {
      console.log('åˆå§‹åŒ–æ™ºèƒ½åœ–ç‰‡æ§åˆ¶ç³»çµ±');
      // å»¶é²åŸ·è¡Œï¼Œç¢ºä¿DOMå…ƒç´ å·²è¼‰å…¥
      setTimeout(function () {
        updatePositionInfo();
      }, 100);
    }

    // é è¦½ä¸Šå‚³çš„åœ–ç‰‡
    function previewUploadedImage() {
      console.log('é–‹å§‹è™•ç†ä¸Šå‚³åœ–ç‰‡');
      var file = document.getElementById('uploadImageFile').files[0];
      if (!file) return;

      var reader = new FileReader();
      reader.onload = function (e) {
        var img = new Image();
        img.onload = function () {
          originalImage = img;
          console.log('åœ–ç‰‡è¼‰å…¥å®Œæˆ:', img.width + 'x' + img.height);

          // è‡ªå‹•è¨­å®šå°ºå¯¸
          document.getElementById('imgWidth').value = Math.min(img.width, 540);
          document.getElementById('imgHeight').value = Math.min(img.height, 960);

          // é¡¯ç¤ºæ§åˆ¶é¢æ¿
          document.getElementById('positionControls').style.display = 'block';
          document.getElementById('effectControls').style.display = 'block';
          document.getElementById('sendImageBtn').disabled = false;

          updatePositionInfo();
          processImageForPreview();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    // è™•ç†åœ–ç‰‡é è¦½
    function processImageForPreview() {
      if (!originalImage) return;

      var canvas = document.getElementById('imagePreviewCanvas');
      if (!canvas) {
        console.log('Preview canvas not found');
        return;
      }

      var ctx = canvas.getContext('2d');
      if (!ctx) {
        console.log('Canvas context not available');
        return;
      }

      var imgWidthEl = document.getElementById('imgWidth');
      var imgHeightEl = document.getElementById('imgHeight');

      if (!imgWidthEl || !imgHeightEl) {
        console.log('Image dimension inputs not found');
        return;
      }

      var w = parseInt(imgWidthEl.value);
      var h = parseInt(imgHeightEl.value);

      canvas.width = w;
      canvas.height = h;

      // ç¹ªè£½ç¸®æ”¾å¾Œçš„åœ–ç‰‡
      ctx.drawImage(originalImage, 0, 0, w, h);

      // å–å¾—åœ–ç‰‡è³‡æ–™
      smartImageData = ctx.getImageData(0, 0, w, h);
      console.log('åœ–ç‰‡è™•ç†å®Œæˆ:', w + 'x' + h);

      // å¥—ç”¨æ¿ƒæ·¡èª¿æ•´
      applyImageAdjustments();
    }

    // å¥—ç”¨åœ–ç‰‡èª¿æ•´
    function applyImageAdjustments() {
      if (!smartImageData) return;

      var canvas = document.getElementById('imagePreviewCanvas');
      var ctx = canvas.getContext('2d');

      var contrast = parseFloat(document.getElementById('contrast').value) / 100;
      var brightness = parseFloat(document.getElementById('brightness').value);

      var imageData = ctx.createImageData(smartImageData.width, smartImageData.height);
      var srcData = smartImageData.data;
      var destData = imageData.data;

      for (var i = 0; i < srcData.length; i += 4) {
        var gray = srcData[i] * 0.299 + srcData[i + 1] * 0.587 + srcData[i + 2] * 0.114;

        // å¥—ç”¨èª¿æ•´
        gray = (gray - 128) * contrast + 128 + brightness;
        gray = Math.max(0, Math.min(255, gray));

        // è½‰æ›ç‚º16éšç°éšé è¦½
        var gray16 = Math.floor(gray / 16);
        gray16 = Math.max(0, Math.min(15, gray16));
        var displayGray = gray16 * 17;

        destData[i] = destData[i + 1] = destData[i + 2] = displayGray;
        destData[i + 3] = 255;
      }

      ctx.putImageData(imageData, 0, 0);
    }

    // æ›´æ–°ä½ç½®è³‡è¨Š
    function updatePositionInfo() {
      // å®‰å…¨æª¢æŸ¥DOMå…ƒç´ æ˜¯å¦å­˜åœ¨
      var imgXEl = document.getElementById('imgX');
      var imgYEl = document.getElementById('imgY');
      var imgWidthEl = document.getElementById('imgWidth');
      var imgHeightEl = document.getElementById('imgHeight');
      var positionInfoEl = document.getElementById('positionInfo');

      if (!imgXEl || !imgYEl || !imgWidthEl || !imgHeightEl) {
        console.log('Position input elements not found, skipping update');
        return;
      }

      var x = parseInt(imgXEl.value) || 0;
      var y = parseInt(imgYEl.value) || 0;
      var w = parseInt(imgWidthEl.value) || 100;
      var h = parseInt(imgHeightEl.value) || 100;

      var info = 'ä½ç½®: (' + x + ', ' + y + ') å°ºå¯¸: ' + w + ' x ' + h + ' åƒç´ ';
      if (x + w > 540 || y + h > 960) {
        info += ' âš ï¸ è¶…å‡ºè¢å¹•ç¯„åœ!';
      }

      if (positionInfoEl) {
        positionInfoEl.textContent = info;
      }

      if (originalImage) {
        processImageForPreview();
      }
    }

    // ç‚ºHTMLæ§ä»¶æä¾›çš„å‡½æ•¸åˆ¥å
    function updateImagePreview() {
      updatePositionInfo();
    }

    // æ›´æ–°å°æ¯”åº¦é¡¯ç¤º
    function updateContrast() {
      var contrast = document.getElementById('contrast').value;
      document.getElementById('contrastValue').textContent = contrast + '%';
      if (smartImageData) {
        applyImageAdjustments();
      }
    }

    // æ›´æ–°äº®åº¦é¡¯ç¤º
    function updateBrightness() {
      var brightness = document.getElementById('brightness').value;
      document.getElementById('brightnessValue').textContent = brightness;
      if (smartImageData) {
        applyImageAdjustments();
      }
    }

    // æ›´æ–°ç°éšç´šæ•¸é¡¯ç¤º
    function updateGrayLevels() {
      var levels = document.getElementById('grayLevels').value;
      document.getElementById('grayLevelsValue').textContent = levels + 'ç´š';
      if (smartImageData) {
        applyImageAdjustments();
      }
    }

    // åç›¸é¡è‰²
    function invertColors() {
      var contrast = document.getElementById('contrast');
      var brightness = document.getElementById('brightness');

      contrast.value = 200 - parseInt(contrast.value);
      brightness.value = -parseInt(brightness.value);

      updateContrast();
      updateBrightness();
    }

    // é‡ç½®æ•ˆæœ
    function resetEffects() {
      document.getElementById('contrast').value = 100;
      document.getElementById('brightness').value = 0;
      document.getElementById('grayLevels').value = 16;

      updateContrast();
      updateBrightness();
      updateGrayLevels();
    }

    // ç™¼é€åœ–ç‰‡åˆ°EPD (å‡½æ•¸åˆ¥å)
    function sendImageToEPD() {
      uploadImageToEPD();
    }

    // è‡ªå‹•é©æ‡‰è¨­å®š
    function fitToScreen() {
      if (!originalImage) {
        alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
        return;
      }

      var scaleX = 540 / originalImage.width;
      var scaleY = 960 / originalImage.height;
      var scale = Math.min(scaleX, scaleY);

      document.getElementById('imgWidth').value = Math.floor(originalImage.width * scale);
      document.getElementById('imgHeight').value = Math.floor(originalImage.height * scale);
      updatePositionInfo();
    }

    // ä¿æŒæ¯”ä¾‹
    function keepAspectRatio() {
      if (!originalImage) return;

      var w = parseInt(document.getElementById('imgWidth').value);
      var ratio = originalImage.height / originalImage.width;

      document.getElementById('imgHeight').value = Math.floor(w * ratio);
      updatePositionInfo();
    }

    // ç½®ä¸­
    function centerImage() {
      var w = parseInt(document.getElementById('imgWidth').value);
      var h = parseInt(document.getElementById('imgHeight').value);

      document.getElementById('imgX').value = Math.floor((540 - w) / 2);
      document.getElementById('imgY').value = Math.floor((960 - h) / 2);
      updatePositionInfo();
    }

    // åç›¸
    function invertImage() {
      var contrast = parseFloat(document.getElementById('imgContrast').value);
      var brightness = parseFloat(document.getElementById('imgBrightness').value);

      document.getElementById('imgContrast').value = -contrast;
      document.getElementById('imgBrightness').value = 255 - brightness;

      if (smartImageData) {
        applyImageAdjustments();
      }
    }

    // é‡è¨­
    function resetImageSettings() {
      document.getElementById('imgX').value = 0;
      document.getElementById('imgY').value = 0;
      document.getElementById('contrast').value = 100;
      document.getElementById('brightness').value = 0;

      if (originalImage) {
        document.getElementById('imgWidth').value = Math.min(originalImage.width, 540);
        document.getElementById('imgHeight').value = Math.min(originalImage.height, 960);
        processImageForPreview();
      }

      updatePositionInfo();
    }

    // ä¸Šå‚³åœ–ç‰‡åˆ°EPD
    function uploadImageToEPD() {
      if (!smartImageData) {
        alert('è«‹å…ˆé¸æ“‡ä¸¦è™•ç†åœ–ç‰‡');
        return;
      }

      var settings = {
        x: parseInt(document.getElementById('imgX').value),
        y: parseInt(document.getElementById('imgY').value),
        w: parseInt(document.getElementById('imgWidth').value),
        h: parseInt(document.getElementById('imgHeight').value),
        contrast: parseFloat(document.getElementById('contrast').value) / 100,
        brightness: parseFloat(document.getElementById('brightness').value)
      };

      console.log('æº–å‚™ä¸Šå‚³åœ–ç‰‡:', settings);

      // é¡¯ç¤ºé€²åº¦æ¢
      var progressDiv = document.getElementById('uploadProgress');
      var progressBar = document.getElementById('progressBar');
      var sendBtn = document.getElementById('sendImageBtn');

      progressDiv.style.display = 'block';
      progressBar.style.width = '10%';
      sendBtn.disabled = true;
      sendBtn.textContent = 'è™•ç†ä¸­...';

      var canvas = document.createElement('canvas');
      canvas.width = settings.w;
      canvas.height = settings.h;
      var ctx = canvas.getContext('2d');

      // èª¿æ•´å°æ¯”åº¦å’Œäº®åº¦
      var imageData = ctx.createImageData(settings.w, settings.h);
      var srcData = smartImageData.data;
      var destData = imageData.data;

      progressBar.style.width = '30%';

      for (var i = 0; i < srcData.length; i += 4) {
        var gray = srcData[i] * 0.299 + srcData[i + 1] * 0.587 + srcData[i + 2] * 0.114;

        // å¥—ç”¨äº®åº¦å’Œå°æ¯”åº¦
        gray = (gray - 128) * settings.contrast + 128 + settings.brightness;
        gray = Math.max(0, Math.min(255, gray));

        // è½‰æ›ç‚º4ä½å…ƒç°éš (0-15)
        var gray4bit = Math.floor(gray / 17);
        gray4bit = Math.max(0, Math.min(15, gray4bit));

        // è½‰å›8ä½å…ƒä¾›é¡¯ç¤º
        var displayGray = gray4bit * 17;

        destData[i] = destData[i + 1] = destData[i + 2] = displayGray;
        destData[i + 3] = 255;
      }

      ctx.putImageData(imageData, 0, 0);
      progressBar.style.width = '60%';

      // è½‰æ›ç‚ºbase64
      var base64Data = canvas.toDataURL('image/png').split(',')[1];
      progressBar.style.width = '80%';

      var uploadData = {
        x: settings.x,
        y: settings.y,
        w: settings.w,
        h: settings.h,
        contrast: settings.contrast,
        brightness: settings.brightness,
        data: base64Data
      };

      // ä½¿ç”¨fetch APIä¸Šå‚³
      fetch('/upload-image', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(uploadData)
      })
        .then(response => response.text())
        .then(data => {
          progressBar.style.width = '100%';
          console.log('ä¸Šå‚³æˆåŠŸ:', data);
          setTimeout(function () {
            progressDiv.style.display = 'none';
            sendBtn.disabled = false;
            sendBtn.textContent = 'ä¸Šå‚³åœ–ç‰‡åˆ° EPD';
            alert('åœ–ç‰‡ä¸Šå‚³æˆåŠŸï¼EPDé¡¯ç¤ºæ›´æ–°å®Œæˆ');
          }, 500);
        })
        .catch(error => {
          console.error('ä¸Šå‚³éŒ¯èª¤:', error);
          progressDiv.style.display = 'none';
          sendBtn.disabled = false;
          sendBtn.textContent = 'ä¸Šå‚³åœ–ç‰‡åˆ° EPD';
          alert('ä¸Šå‚³å¤±æ•—: ' + error);
        });
    }

    // é é¢è¼‰å…¥å®Œæˆåˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function () {
      initImageControls();
    });
  </script>

  <!-- æ™ºèƒ½åœ–ç‰‡æ§åˆ¶ä¸Šå‚³ç³»çµ± -->
  <div class="upload">
    <h3>ğŸ–¼ï¸ æ™ºèƒ½åœ–ç‰‡æ§åˆ¶å™¨</h3>

    <!-- åœ–ç‰‡é¸æ“‡å€ -->
    <div class="form-row">
      <label>é¸æ“‡åœ–ç‰‡:</label>
      <input type="file" id="uploadImageFile" accept="image/*" onchange="previewUploadedImage()">
      <small>æ”¯æ´ JPGã€PNGã€GIFã€BMP ç­‰æ ¼å¼</small>
    </div>

    <!-- åœ–ç‰‡è³‡è¨Šé¡¯ç¤º -->
    <div id="imageInfo" style="margin: 10px 0; color: #666; font-size: 14px;">
      å°šæœªé¸æ“‡åœ–ç‰‡
    </div>

    <!-- åœ–ç‰‡é è¦½å€ -->
    <div id="imagePreview" style="display:none;">
      <h4>é è¦½æ•ˆæœ</h4>
      <div style="text-align: center; margin: 15px 0;">
        <canvas id="imagePreviewCanvas" style="border: 2px solid #333; background: white;"></canvas>
        <div id="positionInfo" style="margin-top: 10px; color: #666; font-size: 12px;">
          ä½ç½®è³‡è¨Šå°‡åœ¨æ­¤é¡¯ç¤º
        </div>
      </div>
    </div>

    <!-- ä½ç½®å’Œå°ºå¯¸æ§åˆ¶ -->
    <div id="positionControls" style="display:none;">
      <h4>ğŸ“ ä½ç½®å’Œå°ºå¯¸æ§åˆ¶</h4>
      <div class="form-row">
        <label>Xåº§æ¨™:</label>
        <input type="number" id="imgX" min="0" max="540" value="0" step="1" onchange="updateImagePreview()">
        <label>Yåº§æ¨™:</label>
        <input type="number" id="imgY" min="0" max="960" value="0" step="1" onchange="updateImagePreview()">
      </div>
      <div class="form-row">
        <label>å¯¬åº¦:</label>
        <input type="number" id="imgWidth" min="1" max="540" value="200" step="1" onchange="updateImagePreview()">
        <label>é«˜åº¦:</label>
        <input type="number" id="imgHeight" min="1" max="960" value="200" step="1" onchange="updateImagePreview()">
      </div>
      <div class="form-row">
        <button onclick="fitToScreen()">ğŸ“± é©æ‡‰è¢å¹•</button>
        <button onclick="keepAspectRatio()">ğŸ“ ä¿æŒæ¯”ä¾‹</button>
        <button onclick="centerImage()">ğŸ¯ ç½®ä¸­</button>
      </div>
    </div>

    <!-- æ•ˆæœæ§åˆ¶ -->
    <div id="effectControls" style="display:none;">
      <h4>ğŸ¨ æ•ˆæœæ§åˆ¶</h4>
      <div class="form-row">
        <label>å°æ¯”åº¦:</label>
        <input type="range" id="contrast" min="0" max="200" value="100" step="5" oninput="updateContrast()">
        <span class="color-value" id="contrastValue">100%</span>
      </div>
      <div class="form-row">
        <label>äº®åº¦:</label>
        <input type="range" id="brightness" min="-100" max="100" value="0" step="5" oninput="updateBrightness()">
        <span class="color-value" id="brightnessValue">0</span>
      </div>
      <div class="form-row">
        <label>ç°éšç´šæ•¸:</label>
        <input type="range" id="grayLevels" min="2" max="16" value="16" step="1" oninput="updateGrayLevels()">
        <span class="color-value" id="grayLevelsValue">16ç´š</span>
      </div>
      <div class="form-row">
        <button onclick="invertColors()">ğŸ”„ åç›¸</button>
        <button onclick="resetEffects()">â†º é‡ç½®æ•ˆæœ</button>
      </div>
    </div>

    <!-- ç™¼é€æ§åˆ¶ -->
    <div class="form-row" style="margin-top: 20px;">
      <button onclick="sendImageToEPD()" id="sendImageBtn" disabled
        style="background: #4CAF50; color: white; font-size: 16px; padding: 12px 24px;">
        ğŸš€ ç™¼é€åœ–ç‰‡åˆ° EPD
      </button>
    </div>

    <!-- é€²åº¦é¡¯ç¤º -->
    <div id="uploadProgress" style="display:none; margin-top: 15px;">
      <div style="background: #f0f0f0; border-radius: 10px; padding: 10px;">
        <div>è™•ç†é€²åº¦ï¼š<span id="progressText">0%</span></div>
        <div style="background: #ddd; border-radius: 5px; margin-top: 5px;">
          <div id="progressBar"
            style="background: #4CAF50; height: 20px; border-radius: 5px; width: 0%; transition: width 0.3s;"></div>
        </div>
      </div>
    </div>
  </div>

</body>

</html>